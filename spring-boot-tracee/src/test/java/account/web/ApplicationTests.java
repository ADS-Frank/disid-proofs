package account.web;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.tuple;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.verify;
import io.tracee.TraceeConstants;

import java.util.List;
import java.util.Map;

import org.assertj.core.api.Condition;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.boot.test.TestRestTemplate;
import org.springframework.boot.test.WebIntegrationTest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import account.Application;
import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.LoggingEvent;
import ch.qos.logback.core.Appender;

/**
 * Basic integration tests for demo application.
 *
 * @author DISID
 */
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(Application.class)
@WebIntegrationTest({"PATH_REPO = /tmp/", "server.port=0", "management.port=0"})
@DirtiesContext
public class ApplicationTests {

  /** JUnit Rule to be able to use Mockito with any JUnit Runner */
  @Rule
  public MockitoRule mockito = MockitoJUnit.rule();

  @Value("${local.server.port}")
  private int port;

  /** 
   * Create a {@link Mock} of a logging {@link Appender} and use it to 
   * validate the interactions with the logging system.
   */
  @Mock
  private Appender<ILoggingEvent> mockAppender;

  /**
   * Mockito argument captor that will capture the logging events send to the
   * {@link #mockAppender}
   */
  @Captor
  private ArgumentCaptor<LoggingEvent> loggingEventCaptor;


  /** 
   * Setup: Get the root logger and add the {@link #mockAppender}
   */
  @Before
  public void setup() {
    final Logger logger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    logger.addAppender(mockAppender);
  }

  /**
   * Teardown: Remove the {@link #mockAppender} from logging after each test
   * to avoid to mix logs between distinct tests.
   */
  @After
  public void teardown() {
    final Logger logger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    logger.detachAppender(mockAppender);
  }

  /**
   * Execute and verify the test that simulates a connection to the 
   * "/accounts?number=1111" URL.
   * @throws Exception
   */
  @Test
  public void testHome() throws Exception {

    // Exercises
    @SuppressWarnings("rawtypes")
    ResponseEntity<Map> entity =
        new TestRestTemplate().getForEntity("http://localhost:" + port + "/accounts?number=1111",
            Map.class);

    // Verify HTTP response
    assertEquals(HttpStatus.OK, entity.getStatusCode());

    @SuppressWarnings("unchecked")
    Map<String, Object> body = entity.getBody();
    assertEquals("1111", body.get("number"));
    assertNotNull(body.get("id"));
    assertNotNull(body.get("creditCardNumber"));

    // Verify logging interactions
    verify(mockAppender, atLeastOnce()).doAppend(loggingEventCaptor.capture());

    // Get the last logging event captured to take the "TPIC.invocationId"
    String TPID =
        loggingEventCaptor.getValue().getMDCPropertyMap().get(TraceeConstants.INVOCATION_ID_KEY);

    // Get the list of logging events captured
    List<LoggingEvent> capturedLoggingEvents = loggingEventCaptor.getAllValues();

    // Filter the captured logging events to get only the events generated by
    // the target class.
    // Use AssertJ "extracting" utility to generate a new list of MDC maps
    // from each of the captured LoggingEvents.
    // Then "extract" again the property "TPIC.invocationId" from each of these
    // Maps and generate a new List of Strings, each of these Strings must
    // be the TracEE TPIC.
    // Finally verify all the TPICs have the expected value.
    assertThat(capturedLoggingEvents).filteredOn("loggerName", "account.web.AccountController")
        .extracting("mdcPropertyMap", Map.class).extracting(TraceeConstants.INVOCATION_ID_KEY)
        .hasSize(2).containsOnly(TPID);

    assertThat(capturedLoggingEvents)
        .filteredOn("loggerName", "account.service.AccountServiceImpl")
        .extracting("mdcPropertyMap", Map.class).extracting(TraceeConstants.INVOCATION_ID_KEY)
        .hasSize(1).containsOnly(TPID);

    // Below validations are not needed, there are just to show some
    // usage examples

    // Use AssertJ "extracting" utility to generate a new list with the value
    // of the "formattedMessage" from each of the LoggingEvent  
    // objects inside the "capturedLoggingEvents" list.
    // Then verify the new list contains the expected logging messages.
    assertThat(capturedLoggingEvents).extracting("formattedMessage", String.class).haveAtLeastOne(
        new SubstringCondition("RESPONSE Account"));

    // Combine the use of AssertJ "extracting" with AssertJ "tuple" to get  
    // more than one attribute from each LogginEvent and validate them together, 
    // for example validate the logging message and the logging level.
    assertThat(capturedLoggingEvents).extracting("formattedMessage", "level").contains(
        tuple("GET Account", Level.INFO));
  }

  /**
   * Custom AssertJ {@link Condition} that will check if the given text
   * in the {@link #matches(String)} method contains the value of the 
   * {@link #substring} attribute.
   * 
   * NOTE: If AssertJ has a similar condition, it will be used in spite of 
   * this class. At the time of writing this proof no similar condition was
   * found.   
   */
  class SubstringCondition extends Condition<String> {

    private String substring;

    public SubstringCondition() {
      super("SubstringCondition");
    }

    public SubstringCondition(String s) {
      this();
      this.substring = s;
    }

    @Override
    public boolean matches(String text) {
      return text.contains(substring);
    }
  }
}
